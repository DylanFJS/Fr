/*
 * Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
 * The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { isPlatformBrowser } from '@angular/common';
import { Component, ContentChild, EventEmitter, HostListener, Inject, Input, Optional, Output, PLATFORM_ID, Self, ViewChild, } from '@angular/core';
import { IF_ACTIVE_ID_PROVIDER } from '../../utils/conditional/if-active.service';
import { Keys } from '../../utils/enums/keys.enum';
import { FOCUS_SERVICE_PROVIDER } from '../../utils/focus/focus.service';
import { ClrLoadingState } from '../../utils/loading/loading';
import { LoadingListener } from '../../utils/loading/loading-listener';
import { ClrAlignment } from '../../utils/popover/enums/alignment.enum';
import { ClrAxis } from '../../utils/popover/enums/axis.enum';
import { ClrSide } from '../../utils/popover/enums/side.enum';
import { ClrPopoverHostDirective } from '../../utils/popover/popover-host.directive';
import { CONTROL_STATE } from '../common/if-control-state/if-control-state.service';
import { WrappedFormControl } from '../common/wrapped-control';
import { ClrComboboxContainer } from './combobox-container';
import { MultiSelectComboboxModel } from './model/multi-select-combobox.model';
import { SingleSelectComboboxModel } from './model/single-select-combobox.model';
import { ClrOptionSelected } from './option-selected.directive';
import { ClrOptions } from './options';
import { COMBOBOX_FOCUS_HANDLER_PROVIDER } from './providers/combobox-focus-handler.service';
import { OptionSelectionService } from './providers/option-selection.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./providers/option-selection.service";
import * as i3 from "../../utils/i18n/common-strings.service";
import * as i4 from "../../utils/popover/providers/popover-toggle.service";
import * as i5 from "../../utils/popover/providers/popover-position.service";
import * as i6 from "../common/if-control-state/if-control-state.service";
import * as i7 from "./providers/combobox-container.service";
import * as i8 from "./providers/combobox-focus-handler.service";
import * as i9 from "../../utils/popover/popover-host.directive";
import * as i10 from "@angular/common";
import * as i11 from "../../icon/icon";
import * as i12 from "../../utils/focus/key-focus/roving-tabindex";
import * as i13 from "../../utils/focus/key-focus/key-focus-item";
import * as i14 from "../../utils/popover/popover-anchor";
import * as i15 from "../../utils/popover/popover-open-close-button";
import * as i16 from "../../utils/popover/popover-content";
export class ClrCombobox extends WrappedFormControl {
    constructor(vcr, injector, control, renderer, el, optionSelectionService, commonStrings, toggleService, positionService, controlStateService, containerService, platformId, focusHandler, cdr) {
        super(vcr, ClrComboboxContainer, injector, control, renderer, el);
        this.control = control;
        this.renderer = renderer;
        this.el = el;
        this.optionSelectionService = optionSelectionService;
        this.commonStrings = commonStrings;
        this.toggleService = toggleService;
        this.positionService = positionService;
        this.controlStateService = controlStateService;
        this.containerService = containerService;
        this.platformId = platformId;
        this.focusHandler = focusHandler;
        this.cdr = cdr;
        this.placeholder = '';
        this.clrInputChange = new EventEmitter(false);
        this.clrOpenChange = this.toggleService.openChange;
        /**
         * This output should be used to set up a live region using aria-live and populate it with updates that reflect each combobox change.
         */
        this.clrSelectionChange = this.optionSelectionService.selectionChanged;
        this.invalid = false;
        this.focused = false;
        this.smartPosition = {
            axis: ClrAxis.VERTICAL,
            side: ClrSide.AFTER,
            anchor: ClrAlignment.START,
            content: ClrAlignment.START,
        };
        this.index = 1;
        this._searchText = '';
        if (control) {
            control.valueAccessor = this;
        }
        // default to SingleSelectComboboxModel, in case the optional input [ClrMulti] isn't used
        this.optionSelectionService.selectionModel = new SingleSelectComboboxModel();
        this.updateControlValue();
    }
    get multiSelect() {
        return this.optionSelectionService.multiselectable;
    }
    set multiSelect(value) {
        if (value) {
            this.optionSelectionService.selectionModel = new MultiSelectComboboxModel();
        }
        else {
            // in theory, setting this again should not cause errors even though we already set it in constructor,
            // since the initial call to writeValue (caused by [ngModel] input) should happen after this
            this.optionSelectionService.selectionModel = new SingleSelectComboboxModel();
        }
        this.updateControlValue();
    }
    // Override the id of WrappedFormControl, as we want to move it to the embedded input.
    // Otherwise the label/component connection does not work and screen readers do not read the label.
    get id() {
        return this.controlIdService.id + '-combobox';
    }
    set id(id) {
        super.id = id;
    }
    get searchText() {
        return this._searchText;
    }
    set searchText(text) {
        // if input text has changed since last time, fire a change event so application can react to it
        if (text !== this._searchText) {
            if (this.toggleService.open) {
                this.optionSelectionService.showAllOptions = false;
            }
            this._searchText = text;
            this.clrInputChange.emit(this.searchText);
        }
        // We need to trigger this even if unchanged, so the option-items directive will update its list
        // based on the "showAllOptions" variable which may have changed in the openChange subscription below.
        // The option-items directive does not listen to openChange, but it listens to currentInput changes.
        this.optionSelectionService.currentInput = this.searchText;
    }
    get openState() {
        return this.toggleService.open;
    }
    get multiSelectModel() {
        if (!this.multiSelect) {
            throw Error('multiSelectModel is not available in single selection context');
        }
        return this.optionSelectionService.selectionModel.model;
    }
    get ariaControls() {
        return this.options?.optionsId;
    }
    get ariaOwns() {
        return this.options?.optionsId;
    }
    get ariaDescribedBySelection() {
        return 'selection-' + this.id;
    }
    get displayField() {
        return this.optionSelectionService.displayField;
    }
    get disabled() {
        return this.control && this.control.disabled;
    }
    ngAfterContentInit() {
        this.initializeSubscriptions();
        // Initialize with preselected value
        if (!this.optionSelectionService.selectionModel.isEmpty()) {
            this.updateInputValue(this.optionSelectionService.selectionModel);
        }
    }
    ngAfterViewInit() {
        this.focusHandler.componentCdRef = this.cdr;
        this.focusHandler.textInput = this.textbox.nativeElement;
        this.focusHandler.trigger = this.trigger.nativeElement;
        // The text input is the actual element we are wrapping
        // This assignment is needed by the wrapper, so it can set
        // the aria properties on the input element, not on the component.
        this.el = this.textbox;
    }
    onKeyUp(event) {
        // if BACKSPACE in multiselect mode, delete the last pill if text is empty
        if (event.key === Keys.Backspace && this.multiSelect && this._searchText.length === 0) {
            const multiModel = this.optionSelectionService.selectionModel.model;
            if (multiModel && multiModel.length > 0) {
                const lastItem = multiModel[multiModel.length - 1];
                this.control.control.markAsTouched();
                this.optionSelectionService.unselect(lastItem);
            }
        }
    }
    inputId() {
        return this.controlIdService.id;
    }
    loadingStateChange(state) {
        this.optionSelectionService.loading = state === ClrLoadingState.LOADING;
        this.positionService.realign();
        if (state !== ClrLoadingState.LOADING && isPlatformBrowser(this.platformId)) {
            this.focusFirstActive();
        }
    }
    unselect(item) {
        if (!this.disabled) {
            this.optionSelectionService.unselect(item);
        }
    }
    onBlur() {
        this.onTouchedCallback();
        if (this.control.control.updateOn === 'change' && this.control.control?.errors?.required) {
            this.updateControlValue();
        }
        if (this.control.control.updateOn === 'blur') {
            this.control.control.updateValueAndValidity();
        }
        this.focused = false;
    }
    onFocus() {
        this.focused = true;
        // fix for "expression changed" error when focus is returned to a combobox after a modal is closed
        // https://github.com/vmware-clarity/ng-clarity/issues/663
        this.cdr.detectChanges();
    }
    getSelectionAriaLabel() {
        if (this.containerService && this.containerService.labelText) {
            return `${this.containerService.labelText} ${this.commonStrings.keys.comboboxSelection}`;
        }
        return this.commonStrings.keys.comboboxSelection;
    }
    focusFirstActive() {
        setTimeout(() => {
            this.focusHandler.focusFirstActive();
        });
    }
    writeValue(value) {
        this.optionSelectionService.selectionModel.model = value;
        this.updateInputValue(this.optionSelectionService.selectionModel);
    }
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    registerOnChange(onChange) {
        this.onChangeCallback = onChange;
    }
    getActiveDescendant() {
        const model = this.focusHandler.pseudoFocus.model;
        return model ? model.id : this.options?.noResultsElementId;
    }
    setDisabledState() {
        // do nothing
    }
    focusInput() {
        this.focusHandler.focusInput();
    }
    initializeSubscriptions() {
        this.subscriptions.push(this.optionSelectionService.selectionChanged.subscribe((newSelection) => {
            this.updateInputValue(newSelection);
            if (this.multiSelect) {
                this.positionService.realign();
            }
            if (!this.multiSelect && newSelection && !newSelection.isEmpty()) {
                this.toggleService.open = false;
            }
            this.updateControlValue();
        }));
        this.subscriptions.push(this.toggleService.openChange.subscribe(open => {
            if (open) {
                this.focusFirstActive();
            }
            else {
                this.optionSelectionService.showAllOptions = true;
            }
            if (this.multiSelect) {
                this.searchText = '';
            }
            else {
                this.searchText = this.getDisplayNames(this.optionSelectionService.selectionModel.model)[0] || '';
            }
        }));
        this.subscriptions.push(this.toggleService.popoverAligned.subscribe(popoverNode => {
            // When used outside a combobox container
            if (!this.containerService) {
                return;
            }
            const popover = popoverNode;
            // Update position if popover hides the label
            if (popover.getBoundingClientRect().top < this.el.nativeElement.getBoundingClientRect().top) {
                this.renderer.setStyle(popoverNode, 'top', `${popover.offsetTop + this.containerService.labelOffset}px`);
            }
        }));
        if (this.controlStateService) {
            this.subscriptions.push(this.controlStateService.statusChanges.subscribe(invalid => {
                this.invalid = this.control.control.touched && invalid === CONTROL_STATE.INVALID;
            }));
        }
    }
    updateInputValue(model) {
        if (!this.multiSelect) {
            this.searchText = model.model ? this.getDisplayNames(model.model)[0] : '';
            if (this.searchText) {
                this.optionSelectionService.currentInput = this.searchText;
            }
        }
    }
    updateControlValue() {
        if (this.onChangeCallback) {
            this.onChangeCallback(this.optionSelectionService.selectionModel.model);
        }
    }
    getDisplayNames(model) {
        if (this.displayField) {
            if (!Array.isArray(model)) {
                model = [model];
            }
            return model.map(item => (item ? item[this.displayField] : null));
        }
        return [this.optionSelectionService.selectionModel.model];
    }
}
ClrCombobox.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrCombobox, deps: [{ token: i0.ViewContainerRef }, { token: i0.Injector }, { token: i1.NgControl, optional: true, self: true }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i2.OptionSelectionService }, { token: i3.ClrCommonStringsService }, { token: i4.ClrPopoverToggleService }, { token: i5.ClrPopoverPositionService }, { token: i6.IfControlStateService, optional: true }, { token: i7.ComboboxContainerService, optional: true }, { token: PLATFORM_ID }, { token: i8.ComboboxFocusHandler }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ClrCombobox.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: ClrCombobox, selector: "clr-combobox", inputs: { placeholder: "placeholder", multiSelect: ["clrMulti", "multiSelect"] }, outputs: { clrInputChange: "clrInputChange", clrOpenChange: "clrOpenChange", clrSelectionChange: "clrSelectionChange" }, host: { listeners: { "keydown": "onKeyUp($event)" }, properties: { "class.aria-required": "true", "class.clr-combobox": "true", "class.clr-combobox-disabled": "control?.disabled" } }, providers: [
        OptionSelectionService,
        { provide: LoadingListener, useExisting: ClrCombobox },
        IF_ACTIVE_ID_PROVIDER,
        FOCUS_SERVICE_PROVIDER,
        COMBOBOX_FOCUS_HANDLER_PROVIDER,
    ], queries: [{ propertyName: "optionSelected", first: true, predicate: ClrOptionSelected, descendants: true }, { propertyName: "options", first: true, predicate: ClrOptions, descendants: true }], viewQueries: [{ propertyName: "textbox", first: true, predicate: ["textboxInput"], descendants: true }, { propertyName: "trigger", first: true, predicate: ["trigger"], descendants: true }], usesInheritance: true, hostDirectives: [{ directive: i9.ClrPopoverHostDirective }], ngImport: i0, template: "<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<!-- The (click) handler is needed to auto-focus on input field which can not currently occupy the whole\n     width of the component, after being wrapped to a new line -->\n<div\n  class=\"clr-combobox-wrapper\"\n  clrPopoverAnchor\n  (click)=\"focusInput()\"\n  [class.multi]=\"multiSelect\"\n  [class.invalid]=\"invalid\"\n  [class.disabled]=\"control?.disabled? true: null\"\n>\n  <span\n    *ngIf=\"multiSelect && optionSelectionService.selectionModel.model\"\n    role=\"grid\"\n    clrRovingTabindex\n    [clrRovingTabindexDisabled]=\"control?.disabled\"\n    clrDirection=\"both\"\n    [attr.aria-label]=\"getSelectionAriaLabel()\"\n    [attr.aria-disabled]=\"control?.disabled? true: null\"\n  >\n    <span *ngFor=\"let item of multiSelectModel; let i = index\" class=\"label label-combobox-pill\" role=\"row\">\n      <span role=\"gridcell\">\n        <span class=\"clr-combobox-pill-content\" clrKeyFocusItem>\n          <ng-container\n            *ngIf=\"optionSelected\"\n            [ngTemplateOutlet]=\"optionSelected.template\"\n            [ngTemplateOutletContext]=\"{$implicit: optionSelectionService.selectionModel.model[i]}\"\n          ></ng-container>\n        </span>\n      </span>\n      <span role=\"gridcell\">\n        <button\n          clrKeyFocusItem\n          type=\"button\"\n          class=\"clr-combobox-remove-btn\"\n          [disabled]=\"control?.disabled? true: null\"\n          [attr.aria-label]=\"commonStrings.keys.comboboxDelete + ' ' + optionSelectionService.selectionModel.toString(displayField, i)\"\n          (click)=\"unselect(item)\"\n        >\n          <cds-icon shape=\"window-close\" size=\"12\"></cds-icon>\n        </button>\n      </span>\n    </span>\n  </span>\n\n  <span class=\"clr-combobox-input-wrapper\">\n    <input\n      #textboxInput\n      type=\"text\"\n      role=\"combobox\"\n      [id]=\"inputId()\"\n      class=\"clr-input clr-combobox-input\"\n      [(ngModel)]=\"searchText\"\n      (blur)=\"onBlur()\"\n      (focus)=\"onFocus()\"\n      [attr.aria-expanded]=\"openState\"\n      [attr.aria-owns]=\"ariaOwns\"\n      aria-haspopup=\"listbox\"\n      aria-autocomplete=\"list\"\n      autocomplete=\"off\"\n      [attr.aria-invalid]=\"control?.invalid? true: null\"\n      [disabled]=\"control?.disabled? true: null\"\n      [attr.aria-activedescendant]=\"getActiveDescendant()\"\n      [attr.placeholder]=\"placeholder\"\n    />\n  </span>\n\n  <!-- No click handler, as it uses the handler on the .clr-combobox-wrapper -->\n  <button\n    clrPopoverOpenCloseButton\n    #trigger\n    type=\"button\"\n    class=\"clr-combobox-trigger\"\n    tabindex=\"-1\"\n    [disabled]=\"control?.disabled || null\"\n    [attr.aria-label]=\"commonStrings.keys.comboboxOpen\"\n  >\n    <cds-icon shape=\"angle\" direction=\"down\"></cds-icon>\n  </button>\n\n  <div class=\"clr-focus-indicator\" [class.clr-focus]=\"focused\"></div>\n</div>\n\n<!-- Both close handlers are handled manually due to issues in Edge browser.\n     Additionally 'outsideClickToClose' has complex handling that's necessary\n     to be manual due to the component architecture -->\n<div role=\"dialog\" *clrPopoverContent=\"openState at smartPosition; outsideClickToClose: false; scrollToClose: false\">\n  <ng-content></ng-content>\n</div>\n", dependencies: [{ kind: "directive", type: i10.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i10.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i11.CdsIconCustomTag, selector: "cds-icon" }, { kind: "component", type: i12.ClrRovingTabindex, selector: "[clrRovingTabindex]", inputs: ["clrRovingTabindex", "clrRovingTabindexDisabled"] }, { kind: "directive", type: i13.ClrKeyFocusItem, selector: "[clrKeyFocusItem]" }, { kind: "directive", type: i14.ClrPopoverAnchor, selector: "[clrPopoverAnchor]" }, { kind: "directive", type: i15.ClrPopoverOpenCloseButton, selector: "[clrPopoverOpenCloseButton]", outputs: ["clrPopoverOpenCloseChange"] }, { kind: "directive", type: i16.ClrPopoverContent, selector: "[clrPopoverContent]", inputs: ["clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrCombobox, decorators: [{
            type: Component,
            args: [{ selector: 'clr-combobox', providers: [
                        OptionSelectionService,
                        { provide: LoadingListener, useExisting: ClrCombobox },
                        IF_ACTIVE_ID_PROVIDER,
                        FOCUS_SERVICE_PROVIDER,
                        COMBOBOX_FOCUS_HANDLER_PROVIDER,
                    ], hostDirectives: [ClrPopoverHostDirective], host: {
                        '[class.aria-required]': 'true',
                        '[class.clr-combobox]': 'true',
                        '[class.clr-combobox-disabled]': 'control?.disabled',
                    }, template: "<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<!-- The (click) handler is needed to auto-focus on input field which can not currently occupy the whole\n     width of the component, after being wrapped to a new line -->\n<div\n  class=\"clr-combobox-wrapper\"\n  clrPopoverAnchor\n  (click)=\"focusInput()\"\n  [class.multi]=\"multiSelect\"\n  [class.invalid]=\"invalid\"\n  [class.disabled]=\"control?.disabled? true: null\"\n>\n  <span\n    *ngIf=\"multiSelect && optionSelectionService.selectionModel.model\"\n    role=\"grid\"\n    clrRovingTabindex\n    [clrRovingTabindexDisabled]=\"control?.disabled\"\n    clrDirection=\"both\"\n    [attr.aria-label]=\"getSelectionAriaLabel()\"\n    [attr.aria-disabled]=\"control?.disabled? true: null\"\n  >\n    <span *ngFor=\"let item of multiSelectModel; let i = index\" class=\"label label-combobox-pill\" role=\"row\">\n      <span role=\"gridcell\">\n        <span class=\"clr-combobox-pill-content\" clrKeyFocusItem>\n          <ng-container\n            *ngIf=\"optionSelected\"\n            [ngTemplateOutlet]=\"optionSelected.template\"\n            [ngTemplateOutletContext]=\"{$implicit: optionSelectionService.selectionModel.model[i]}\"\n          ></ng-container>\n        </span>\n      </span>\n      <span role=\"gridcell\">\n        <button\n          clrKeyFocusItem\n          type=\"button\"\n          class=\"clr-combobox-remove-btn\"\n          [disabled]=\"control?.disabled? true: null\"\n          [attr.aria-label]=\"commonStrings.keys.comboboxDelete + ' ' + optionSelectionService.selectionModel.toString(displayField, i)\"\n          (click)=\"unselect(item)\"\n        >\n          <cds-icon shape=\"window-close\" size=\"12\"></cds-icon>\n        </button>\n      </span>\n    </span>\n  </span>\n\n  <span class=\"clr-combobox-input-wrapper\">\n    <input\n      #textboxInput\n      type=\"text\"\n      role=\"combobox\"\n      [id]=\"inputId()\"\n      class=\"clr-input clr-combobox-input\"\n      [(ngModel)]=\"searchText\"\n      (blur)=\"onBlur()\"\n      (focus)=\"onFocus()\"\n      [attr.aria-expanded]=\"openState\"\n      [attr.aria-owns]=\"ariaOwns\"\n      aria-haspopup=\"listbox\"\n      aria-autocomplete=\"list\"\n      autocomplete=\"off\"\n      [attr.aria-invalid]=\"control?.invalid? true: null\"\n      [disabled]=\"control?.disabled? true: null\"\n      [attr.aria-activedescendant]=\"getActiveDescendant()\"\n      [attr.placeholder]=\"placeholder\"\n    />\n  </span>\n\n  <!-- No click handler, as it uses the handler on the .clr-combobox-wrapper -->\n  <button\n    clrPopoverOpenCloseButton\n    #trigger\n    type=\"button\"\n    class=\"clr-combobox-trigger\"\n    tabindex=\"-1\"\n    [disabled]=\"control?.disabled || null\"\n    [attr.aria-label]=\"commonStrings.keys.comboboxOpen\"\n  >\n    <cds-icon shape=\"angle\" direction=\"down\"></cds-icon>\n  </button>\n\n  <div class=\"clr-focus-indicator\" [class.clr-focus]=\"focused\"></div>\n</div>\n\n<!-- Both close handlers are handled manually due to issues in Edge browser.\n     Additionally 'outsideClickToClose' has complex handling that's necessary\n     to be manual due to the component architecture -->\n<div role=\"dialog\" *clrPopoverContent=\"openState at smartPosition; outsideClickToClose: false; scrollToClose: false\">\n  <ng-content></ng-content>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.Injector }, { type: i1.NgControl, decorators: [{
                    type: Self
                }, {
                    type: Optional
                }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i2.OptionSelectionService }, { type: i3.ClrCommonStringsService }, { type: i4.ClrPopoverToggleService }, { type: i5.ClrPopoverPositionService }, { type: i6.IfControlStateService, decorators: [{
                    type: Optional
                }] }, { type: i7.ComboboxContainerService, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i8.ComboboxFocusHandler }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { placeholder: [{
                type: Input,
                args: ['placeholder']
            }], clrInputChange: [{
                type: Output,
                args: ['clrInputChange']
            }], clrOpenChange: [{
                type: Output,
                args: ['clrOpenChange']
            }], clrSelectionChange: [{
                type: Output,
                args: ['clrSelectionChange']
            }], textbox: [{
                type: ViewChild,
                args: ['textboxInput']
            }], trigger: [{
                type: ViewChild,
                args: ['trigger']
            }], optionSelected: [{
                type: ContentChild,
                args: [ClrOptionSelected]
            }], options: [{
                type: ContentChild,
                args: [ClrOptions]
            }], multiSelect: [{
                type: Input,
                args: ['clrMulti']
            }], onKeyUp: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tYm9ib3guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyL3NyYy9mb3Jtcy9jb21ib2JveC9jb21ib2JveC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2Zvcm1zL2NvbWJvYm94L2NvbWJvYm94Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0dBS0c7QUFFSCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBR0wsU0FBUyxFQUNULFlBQVksRUFFWixZQUFZLEVBQ1osWUFBWSxFQUNaLE1BQU0sRUFFTixLQUFLLEVBQ0wsUUFBUSxFQUNSLE1BQU0sRUFDTixXQUFXLEVBRVgsSUFBSSxFQUNKLFNBQVMsR0FFVixNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUNsRixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDbkQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFekUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzlELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUN2RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFDeEUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzlELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUU5RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw0Q0FBNEMsQ0FBQztBQUdyRixPQUFPLEVBQUUsYUFBYSxFQUF5QixNQUFNLHFEQUFxRCxDQUFDO0FBQzNHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FB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QUFTO3VCQUFDLFNBQVM7Z0JBQ2EsY0FBYztzQkFBOUMsWUFBWTt1QkFBQyxpQkFBaUI7Z0JBZUcsT0FBTztzQkFBeEMsWUFBWTt1QkFBQyxVQUFVO2dCQWtDcEIsV0FBVztzQkFEZCxLQUFLO3VCQUFDLFVBQVU7Z0JBNkZqQixPQUFPO3NCQUROLFlBQVk7dUJBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDI0IEJyb2FkY29tLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhlIHRlcm0gXCJCcm9hZGNvbVwiIHJlZmVycyB0byBCcm9hZGNvbSBJbmMuIGFuZC9vciBpdHMgc3Vic2lkaWFyaWVzLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3QsXG4gIEluamVjdG9yLFxuICBJbnB1dCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUExBVEZPUk1fSUQsXG4gIFJlbmRlcmVyMixcbiAgU2VsZixcbiAgVmlld0NoaWxkLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElGX0FDVElWRV9JRF9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IEtleXMgfSBmcm9tICcuLi8uLi91dGlscy9lbnVtcy9rZXlzLmVudW0nO1xuaW1wb3J0IHsgRk9DVVNfU0VSVklDRV9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzL2ZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ1N0YXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nJztcbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBDbHJBbGlnbm1lbnQgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL2VudW1zL2FsaWdubWVudC5lbnVtJztcbmltcG9ydCB7IENsckF4aXMgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL2VudW1zL2F4aXMuZW51bSc7XG5pbXBvcnQgeyBDbHJTaWRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9lbnVtcy9zaWRlLmVudW0nO1xuaW1wb3J0IHsgQ2xyUG9wb3ZlclBvc2l0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9pbnRlcmZhY2VzL3BvcG92ZXItcG9zaXRpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IENsclBvcG92ZXJIb3N0RGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9wb3BvdmVyLWhvc3QuZGlyZWN0aXZlJztcbmltcG9ydCB7IENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL3Byb3ZpZGVycy9wb3BvdmVyLXBvc2l0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9wb3BvdmVyL3Byb3ZpZGVycy9wb3BvdmVyLXRvZ2dsZS5zZXJ2aWNlJztcbmltcG9ydCB7IENPTlRST0xfU1RBVEUsIElmQ29udHJvbFN0YXRlU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1jb250cm9sLXN0YXRlL2lmLWNvbnRyb2wtc3RhdGUuc2VydmljZSc7XG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcbmltcG9ydCB7IENsckNvbWJvYm94Q29udGFpbmVyIH0gZnJvbSAnLi9jb21ib2JveC1jb250YWluZXInO1xuaW1wb3J0IHsgQ29tYm9ib3hNb2RlbCB9IGZyb20gJy4vbW9kZWwvY29tYm9ib3gubW9kZWwnO1xuaW1wb3J0IHsgTXVsdGlTZWxlY3RDb21ib2JveE1vZGVsIH0gZnJvbSAnLi9tb2RlbC9tdWx0aS1zZWxlY3QtY29tYm9ib3gubW9kZWwnO1xuaW1wb3J0IHsgU2luZ2xlU2VsZWN0Q29tYm9ib3hNb2RlbCB9IGZyb20gJy4vbW9kZWwvc2luZ2xlLXNlbGVjdC1jb21ib2JveC5tb2RlbCc7XG5pbXBvcnQgeyBDbHJPcHRpb25TZWxlY3RlZCB9IGZyb20gJy4vb3B0aW9uLXNlbGVjdGVkLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IENvbWJvYm94Q29udGFpbmVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbWJvYm94LWNvbnRhaW5lci5zZXJ2aWNlJztcbmltcG9ydCB7IENPTUJPQk9YX0ZPQ1VTX0hBTkRMRVJfUFJPVklERVIsIENvbWJvYm94Rm9jdXNIYW5kbGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvY29tYm9ib3gtZm9jdXMtaGFuZGxlci5zZXJ2aWNlJztcbmltcG9ydCB7IE9wdGlvblNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9vcHRpb24tc2VsZWN0aW9uLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItY29tYm9ib3gnLFxuICB0ZW1wbGF0ZVVybDogJy4vY29tYm9ib3guaHRtbCcsXG4gIHByb3ZpZGVyczogW1xuICAgIE9wdGlvblNlbGVjdGlvblNlcnZpY2UsXG4gICAgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBDbHJDb21ib2JveCB9LFxuICAgIElGX0FDVElWRV9JRF9QUk9WSURFUixcbiAgICBGT0NVU19TRVJWSUNFX1BST1ZJREVSLFxuICAgIENPTUJPQk9YX0ZPQ1VTX0hBTkRMRVJfUFJPVklERVIsXG4gIF0sXG4gIGhvc3REaXJlY3RpdmVzOiBbQ2xyUG9wb3Zlckhvc3REaXJlY3RpdmVdLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5hcmlhLXJlcXVpcmVkXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1jb21ib2JveF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItY29tYm9ib3gtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ29tYm9ib3g8VD5cbiAgZXh0ZW5kcyBXcmFwcGVkRm9ybUNvbnRyb2w8Q2xyQ29tYm9ib3hDb250YWluZXI+XG4gIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIExvYWRpbmdMaXN0ZW5lciwgQWZ0ZXJDb250ZW50SW5pdFxue1xuICBASW5wdXQoJ3BsYWNlaG9sZGVyJykgcGxhY2Vob2xkZXIgPSAnJztcblxuICBAT3V0cHV0KCdjbHJJbnB1dENoYW5nZScpIGNscklucHV0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KGZhbHNlKTtcbiAgQE91dHB1dCgnY2xyT3BlbkNoYW5nZScpIGNsck9wZW5DaGFuZ2UgPSB0aGlzLnRvZ2dsZVNlcnZpY2Uub3BlbkNoYW5nZTtcblxuICAvKipcbiAgICogVGhpcyBvdXRwdXQgc2hvdWxkIGJlIHVzZWQgdG8gc2V0IHVwIGEgbGl2ZSByZWdpb24gdXNpbmcgYXJpYS1saXZlIGFuZCBwb3B1bGF0ZSBpdCB3aXRoIHVwZGF0ZXMgdGhhdCByZWZsZWN0IGVhY2ggY29tYm9ib3ggY2hhbmdlLlxuICAgKi9cbiAgQE91dHB1dCgnY2xyU2VsZWN0aW9uQ2hhbmdlJykgY2xyU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbkNoYW5nZWQ7XG5cbiAgQFZpZXdDaGlsZCgndGV4dGJveElucHV0JykgdGV4dGJveDogRWxlbWVudFJlZjtcbiAgQFZpZXdDaGlsZCgndHJpZ2dlcicpIHRyaWdnZXI6IEVsZW1lbnRSZWY7XG4gIEBDb250ZW50Q2hpbGQoQ2xyT3B0aW9uU2VsZWN0ZWQpIG9wdGlvblNlbGVjdGVkOiBDbHJPcHRpb25TZWxlY3RlZDxUPjtcblxuICBpbnZhbGlkID0gZmFsc2U7XG4gIGZvY3VzZWQgPSBmYWxzZTtcbiAgZm9jdXNlZFBpbGw6IGFueTtcblxuICBzbWFydFBvc2l0aW9uOiBDbHJQb3BvdmVyUG9zaXRpb24gPSB7XG4gICAgYXhpczogQ2xyQXhpcy5WRVJUSUNBTCxcbiAgICBzaWRlOiBDbHJTaWRlLkFGVEVSLFxuICAgIGFuY2hvcjogQ2xyQWxpZ25tZW50LlNUQVJULFxuICAgIGNvbnRlbnQ6IENsckFsaWdubWVudC5TVEFSVCxcbiAgfTtcblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgaW5kZXggPSAxO1xuXG4gIEBDb250ZW50Q2hpbGQoQ2xyT3B0aW9ucykgcHJpdmF0ZSBvcHRpb25zOiBDbHJPcHRpb25zPFQ+O1xuXG4gIHByaXZhdGUgX3NlYXJjaFRleHQgPSAnJztcbiAgcHJpdmF0ZSBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gYW55O1xuICBwcml2YXRlIG9uQ2hhbmdlQ2FsbGJhY2s6IChtb2RlbDogVCB8IFRbXSkgPT4gYW55O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHVibGljIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHVibGljIG9wdGlvblNlbGVjdGlvblNlcnZpY2U6IE9wdGlvblNlbGVjdGlvblNlcnZpY2U8VD4sXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgdG9nZ2xlU2VydmljZTogQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBwb3NpdGlvblNlcnZpY2U6IENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sU3RhdGVTZXJ2aWNlOiBJZkNvbnRyb2xTdGF0ZVNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250YWluZXJTZXJ2aWNlOiBDb21ib2JveENvbnRhaW5lclNlcnZpY2UsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBhbnksXG4gICAgcHJpdmF0ZSBmb2N1c0hhbmRsZXI6IENvbWJvYm94Rm9jdXNIYW5kbGVyPFQ+LFxuICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENsckNvbWJvYm94Q29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgICBpZiAoY29udHJvbCkge1xuICAgICAgY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICB9XG4gICAgLy8gZGVmYXVsdCB0byBTaW5nbGVTZWxlY3RDb21ib2JveE1vZGVsLCBpbiBjYXNlIHRoZSBvcHRpb25hbCBpbnB1dCBbQ2xyTXVsdGldIGlzbid0IHVzZWRcbiAgICB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2luZ2xlU2VsZWN0Q29tYm9ib3hNb2RlbDxUPigpO1xuICAgIHRoaXMudXBkYXRlQ29udHJvbFZhbHVlKCk7XG4gIH1cblxuICBASW5wdXQoJ2Nsck11bHRpJylcbiAgZ2V0IG11bHRpU2VsZWN0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2UubXVsdGlzZWxlY3RhYmxlO1xuICB9XG4gIHNldCBtdWx0aVNlbGVjdCh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsID0gbmV3IE11bHRpU2VsZWN0Q29tYm9ib3hNb2RlbDxUPigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiB0aGVvcnksIHNldHRpbmcgdGhpcyBhZ2FpbiBzaG91bGQgbm90IGNhdXNlIGVycm9ycyBldmVuIHRob3VnaCB3ZSBhbHJlYWR5IHNldCBpdCBpbiBjb25zdHJ1Y3RvcixcbiAgICAgIC8vIHNpbmNlIHRoZSBpbml0aWFsIGNhbGwgdG8gd3JpdGVWYWx1ZSAoY2F1c2VkIGJ5IFtuZ01vZGVsXSBpbnB1dCkgc2hvdWxkIGhhcHBlbiBhZnRlciB0aGlzXG4gICAgICB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2luZ2xlU2VsZWN0Q29tYm9ib3hNb2RlbDxUPigpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbnRyb2xWYWx1ZSgpO1xuICB9XG5cbiAgLy8gT3ZlcnJpZGUgdGhlIGlkIG9mIFdyYXBwZWRGb3JtQ29udHJvbCwgYXMgd2Ugd2FudCB0byBtb3ZlIGl0IHRvIHRoZSBlbWJlZGRlZCBpbnB1dC5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBsYWJlbC9jb21wb25lbnQgY29ubmVjdGlvbiBkb2VzIG5vdCB3b3JrIGFuZCBzY3JlZW4gcmVhZGVycyBkbyBub3QgcmVhZCB0aGUgbGFiZWwuXG4gIG92ZXJyaWRlIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkICsgJy1jb21ib2JveCc7XG4gIH1cbiAgb3ZlcnJpZGUgc2V0IGlkKGlkOiBzdHJpbmcpIHtcbiAgICBzdXBlci5pZCA9IGlkO1xuICB9XG5cbiAgZ2V0IHNlYXJjaFRleHQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoVGV4dDtcbiAgfVxuICBzZXQgc2VhcmNoVGV4dCh0ZXh0OiBzdHJpbmcpIHtcbiAgICAvLyBpZiBpbnB1dCB0ZXh0IGhhcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdGltZSwgZmlyZSBhIGNoYW5nZSBldmVudCBzbyBhcHBsaWNhdGlvbiBjYW4gcmVhY3QgdG8gaXRcbiAgICBpZiAodGV4dCAhPT0gdGhpcy5fc2VhcmNoVGV4dCkge1xuICAgICAgaWYgKHRoaXMudG9nZ2xlU2VydmljZS5vcGVuKSB7XG4gICAgICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zaG93QWxsT3B0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VhcmNoVGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLmNscklucHV0Q2hhbmdlLmVtaXQodGhpcy5zZWFyY2hUZXh0KTtcbiAgICB9XG4gICAgLy8gV2UgbmVlZCB0byB0cmlnZ2VyIHRoaXMgZXZlbiBpZiB1bmNoYW5nZWQsIHNvIHRoZSBvcHRpb24taXRlbXMgZGlyZWN0aXZlIHdpbGwgdXBkYXRlIGl0cyBsaXN0XG4gICAgLy8gYmFzZWQgb24gdGhlIFwic2hvd0FsbE9wdGlvbnNcIiB2YXJpYWJsZSB3aGljaCBtYXkgaGF2ZSBjaGFuZ2VkIGluIHRoZSBvcGVuQ2hhbmdlIHN1YnNjcmlwdGlvbiBiZWxvdy5cbiAgICAvLyBUaGUgb3B0aW9uLWl0ZW1zIGRpcmVjdGl2ZSBkb2VzIG5vdCBsaXN0ZW4gdG8gb3BlbkNoYW5nZSwgYnV0IGl0IGxpc3RlbnMgdG8gY3VycmVudElucHV0IGNoYW5nZXMuXG4gICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLmN1cnJlbnRJbnB1dCA9IHRoaXMuc2VhcmNoVGV4dDtcbiAgfVxuXG4gIGdldCBvcGVuU3RhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlU2VydmljZS5vcGVuO1xuICB9XG5cbiAgZ2V0IG11bHRpU2VsZWN0TW9kZWwoKTogVFtdIHtcbiAgICBpZiAoIXRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgIHRocm93IEVycm9yKCdtdWx0aVNlbGVjdE1vZGVsIGlzIG5vdCBhdmFpbGFibGUgaW4gc2luZ2xlIHNlbGVjdGlvbiBjb250ZXh0Jyk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsIGFzIE11bHRpU2VsZWN0Q29tYm9ib3hNb2RlbDxUPikubW9kZWw7XG4gIH1cblxuICBnZXQgYXJpYUNvbnRyb2xzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucz8ub3B0aW9uc0lkO1xuICB9XG5cbiAgZ2V0IGFyaWFPd25zKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucz8ub3B0aW9uc0lkO1xuICB9XG5cbiAgZ2V0IGFyaWFEZXNjcmliZWRCeVNlbGVjdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnc2VsZWN0aW9uLScgKyB0aGlzLmlkO1xuICB9XG5cbiAgZ2V0IGRpc3BsYXlGaWVsZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2UuZGlzcGxheUZpZWxkO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbCAmJiB0aGlzLmNvbnRyb2wuZGlzYWJsZWQ7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplU3Vic2NyaXB0aW9ucygpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHByZXNlbGVjdGVkIHZhbHVlXG4gICAgaWYgKCF0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5mb2N1c0hhbmRsZXIuY29tcG9uZW50Q2RSZWYgPSB0aGlzLmNkcjtcbiAgICB0aGlzLmZvY3VzSGFuZGxlci50ZXh0SW5wdXQgPSB0aGlzLnRleHRib3gubmF0aXZlRWxlbWVudDtcbiAgICB0aGlzLmZvY3VzSGFuZGxlci50cmlnZ2VyID0gdGhpcy50cmlnZ2VyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgLy8gVGhlIHRleHQgaW5wdXQgaXMgdGhlIGFjdHVhbCBlbGVtZW50IHdlIGFyZSB3cmFwcGluZ1xuICAgIC8vIFRoaXMgYXNzaWdubWVudCBpcyBuZWVkZWQgYnkgdGhlIHdyYXBwZXIsIHNvIGl0IGNhbiBzZXRcbiAgICAvLyB0aGUgYXJpYSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnB1dCBlbGVtZW50LCBub3Qgb24gdGhlIGNvbXBvbmVudC5cbiAgICB0aGlzLmVsID0gdGhpcy50ZXh0Ym94O1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gIG9uS2V5VXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBpZiBCQUNLU1BBQ0UgaW4gbXVsdGlzZWxlY3QgbW9kZSwgZGVsZXRlIHRoZSBsYXN0IHBpbGwgaWYgdGV4dCBpcyBlbXB0eVxuICAgIGlmIChldmVudC5rZXkgPT09IEtleXMuQmFja3NwYWNlICYmIHRoaXMubXVsdGlTZWxlY3QgJiYgdGhpcy5fc2VhcmNoVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IG11bHRpTW9kZWw6IFRbXSA9IHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbC5tb2RlbCBhcyBUW107XG4gICAgICBpZiAobXVsdGlNb2RlbCAmJiBtdWx0aU1vZGVsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbGFzdEl0ZW06IFQgPSBtdWx0aU1vZGVsW211bHRpTW9kZWwubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY29udHJvbC5jb250cm9sLm1hcmtBc1RvdWNoZWQoKTtcbiAgICAgICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnVuc2VsZWN0KGxhc3RJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnB1dElkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbElkU2VydmljZS5pZDtcbiAgfVxuXG4gIGxvYWRpbmdTdGF0ZUNoYW5nZShzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlKTogdm9pZCB7XG4gICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLmxvYWRpbmcgPSBzdGF0ZSA9PT0gQ2xyTG9hZGluZ1N0YXRlLkxPQURJTkc7XG4gICAgdGhpcy5wb3NpdGlvblNlcnZpY2UucmVhbGlnbigpO1xuICAgIGlmIChzdGF0ZSAhPT0gQ2xyTG9hZGluZ1N0YXRlLkxPQURJTkcgJiYgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgdGhpcy5mb2N1c0ZpcnN0QWN0aXZlKCk7XG4gICAgfVxuICB9XG5cbiAgdW5zZWxlY3QoaXRlbTogVCkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnVuc2VsZWN0KGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIG9uQmx1cigpIHtcbiAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgaWYgKHRoaXMuY29udHJvbC5jb250cm9sLnVwZGF0ZU9uID09PSAnY2hhbmdlJyAmJiB0aGlzLmNvbnRyb2wuY29udHJvbD8uZXJyb3JzPy5yZXF1aXJlZCkge1xuICAgICAgdGhpcy51cGRhdGVDb250cm9sVmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udHJvbC5jb250cm9sLnVwZGF0ZU9uID09PSAnYmx1cicpIHtcbiAgICAgIHRoaXMuY29udHJvbC5jb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICB9XG4gICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gIH1cblxuICBvbkZvY3VzKCkge1xuICAgIHRoaXMuZm9jdXNlZCA9IHRydWU7XG5cbiAgICAvLyBmaXggZm9yIFwiZXhwcmVzc2lvbiBjaGFuZ2VkXCIgZXJyb3Igd2hlbiBmb2N1cyBpcyByZXR1cm5lZCB0byBhIGNvbWJvYm94IGFmdGVyIGEgbW9kYWwgaXMgY2xvc2VkXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS1jbGFyaXR5L25nLWNsYXJpdHkvaXNzdWVzLzY2M1xuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIGdldFNlbGVjdGlvbkFyaWFMYWJlbCgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXJTZXJ2aWNlICYmIHRoaXMuY29udGFpbmVyU2VydmljZS5sYWJlbFRleHQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmNvbnRhaW5lclNlcnZpY2UubGFiZWxUZXh0fSAke3RoaXMuY29tbW9uU3RyaW5ncy5rZXlzLmNvbWJvYm94U2VsZWN0aW9ufWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy5jb21ib2JveFNlbGVjdGlvbjtcbiAgfVxuXG4gIGZvY3VzRmlyc3RBY3RpdmUoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmZvY3VzSGFuZGxlci5mb2N1c0ZpcnN0QWN0aXZlKCk7XG4gICAgfSk7XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBUIHwgVFtdKTogdm9pZCB7XG4gICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsLm1vZGVsID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVJbnB1dFZhbHVlKHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbCk7XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChvblRvdWNoZWQ6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBvblRvdWNoZWQ7XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKG9uQ2hhbmdlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZTtcbiAgfVxuXG4gIGdldEFjdGl2ZURlc2NlbmRhbnQoKSB7XG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLmZvY3VzSGFuZGxlci5wc2V1ZG9Gb2N1cy5tb2RlbDtcbiAgICByZXR1cm4gbW9kZWwgPyBtb2RlbC5pZCA6IHRoaXMub3B0aW9ucz8ubm9SZXN1bHRzRWxlbWVudElkO1xuICB9XG5cbiAgc2V0RGlzYWJsZWRTdGF0ZSgpOiB2b2lkIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBmb2N1c0lucHV0KCkge1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyLmZvY3VzSW5wdXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uQ2hhbmdlZC5zdWJzY3JpYmUoKG5ld1NlbGVjdGlvbjogQ29tYm9ib3hNb2RlbDxUPikgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUlucHV0VmFsdWUobmV3U2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uU2VydmljZS5yZWFsaWduKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpU2VsZWN0ICYmIG5ld1NlbGVjdGlvbiAmJiAhbmV3U2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVDb250cm9sVmFsdWUoKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy50b2dnbGVTZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKG9wZW4gPT4ge1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgIHRoaXMuZm9jdXNGaXJzdEFjdGl2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zaG93QWxsT3B0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICB0aGlzLnNlYXJjaFRleHQgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlYXJjaFRleHQgPSB0aGlzLmdldERpc3BsYXlOYW1lcyh0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwubW9kZWwpWzBdIHx8ICcnO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMudG9nZ2xlU2VydmljZS5wb3BvdmVyQWxpZ25lZC5zdWJzY3JpYmUocG9wb3Zlck5vZGUgPT4ge1xuICAgICAgICAvLyBXaGVuIHVzZWQgb3V0c2lkZSBhIGNvbWJvYm94IGNvbnRhaW5lclxuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyU2VydmljZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BvdmVyOiBIVE1MRWxlbWVudCA9IHBvcG92ZXJOb2RlIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb24gaWYgcG9wb3ZlciBoaWRlcyB0aGUgbGFiZWxcbiAgICAgICAgaWYgKHBvcG92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDwgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocG9wb3Zlck5vZGUsICd0b3AnLCBgJHtwb3BvdmVyLm9mZnNldFRvcCArIHRoaXMuY29udGFpbmVyU2VydmljZS5sYWJlbE9mZnNldH1weGApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5jb250cm9sU3RhdGVTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5jb250cm9sU3RhdGVTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICAgIHRoaXMuaW52YWxpZCA9IHRoaXMuY29udHJvbC5jb250cm9sLnRvdWNoZWQgJiYgaW52YWxpZCA9PT0gQ09OVFJPTF9TVEFURS5JTlZBTElEO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUlucHV0VmFsdWUobW9kZWw6IENvbWJvYm94TW9kZWw8VD4pIHtcbiAgICBpZiAoIXRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgIHRoaXMuc2VhcmNoVGV4dCA9IG1vZGVsLm1vZGVsID8gdGhpcy5nZXREaXNwbGF5TmFtZXMobW9kZWwubW9kZWwpWzBdIDogJyc7XG4gICAgICBpZiAodGhpcy5zZWFyY2hUZXh0KSB7XG4gICAgICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5jdXJyZW50SW5wdXQgPSB0aGlzLnNlYXJjaFRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDb250cm9sVmFsdWUoKSB7XG4gICAgaWYgKHRoaXMub25DaGFuZ2VDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbC5tb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXREaXNwbGF5TmFtZXMobW9kZWw6IFQgfCBUW10pIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5RmllbGQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RlbCkpIHtcbiAgICAgICAgbW9kZWwgPSBbbW9kZWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZGVsLm1hcChpdGVtID0+IChpdGVtID8gKGl0ZW0gYXMgYW55KVt0aGlzLmRpc3BsYXlGaWVsZF0gOiBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBbdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsLm1vZGVsXTtcbiAgfVxufVxuIiwiPCEtLVxuICB+IENvcHlyaWdodCAoYykgMjAxNi0yMDI0IEJyb2FkY29tLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICB+IFRoZSB0ZXJtIFwiQnJvYWRjb21cIiByZWZlcnMgdG8gQnJvYWRjb20gSW5jLiBhbmQvb3IgaXRzIHN1YnNpZGlhcmllcy5cbiAgfiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICB+IFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbi0tPlxuXG48IS0tIFRoZSAoY2xpY2spIGhhbmRsZXIgaXMgbmVlZGVkIHRvIGF1dG8tZm9jdXMgb24gaW5wdXQgZmllbGQgd2hpY2ggY2FuIG5vdCBjdXJyZW50bHkgb2NjdXB5IHRoZSB3aG9sZVxuICAgICB3aWR0aCBvZiB0aGUgY29tcG9uZW50LCBhZnRlciBiZWluZyB3cmFwcGVkIHRvIGEgbmV3IGxpbmUgLS0+XG48ZGl2XG4gIGNsYXNzPVwiY2xyLWNvbWJvYm94LXdyYXBwZXJcIlxuICBjbHJQb3BvdmVyQW5jaG9yXG4gIChjbGljayk9XCJmb2N1c0lucHV0KClcIlxuICBbY2xhc3MubXVsdGldPVwibXVsdGlTZWxlY3RcIlxuICBbY2xhc3MuaW52YWxpZF09XCJpbnZhbGlkXCJcbiAgW2NsYXNzLmRpc2FibGVkXT1cImNvbnRyb2w/LmRpc2FibGVkPyB0cnVlOiBudWxsXCJcbj5cbiAgPHNwYW5cbiAgICAqbmdJZj1cIm11bHRpU2VsZWN0ICYmIG9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwubW9kZWxcIlxuICAgIHJvbGU9XCJncmlkXCJcbiAgICBjbHJSb3ZpbmdUYWJpbmRleFxuICAgIFtjbHJSb3ZpbmdUYWJpbmRleERpc2FibGVkXT1cImNvbnRyb2w/LmRpc2FibGVkXCJcbiAgICBjbHJEaXJlY3Rpb249XCJib3RoXCJcbiAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImdldFNlbGVjdGlvbkFyaWFMYWJlbCgpXCJcbiAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImNvbnRyb2w/LmRpc2FibGVkPyB0cnVlOiBudWxsXCJcbiAgPlxuICAgIDxzcGFuICpuZ0Zvcj1cImxldCBpdGVtIG9mIG11bHRpU2VsZWN0TW9kZWw7IGxldCBpID0gaW5kZXhcIiBjbGFzcz1cImxhYmVsIGxhYmVsLWNvbWJvYm94LXBpbGxcIiByb2xlPVwicm93XCI+XG4gICAgICA8c3BhbiByb2xlPVwiZ3JpZGNlbGxcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJjbHItY29tYm9ib3gtcGlsbC1jb250ZW50XCIgY2xyS2V5Rm9jdXNJdGVtPlxuICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ0lmPVwib3B0aW9uU2VsZWN0ZWRcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwib3B0aW9uU2VsZWN0ZWQudGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IG9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwubW9kZWxbaV19XCJcbiAgICAgICAgICA+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5cbiAgICAgIDxzcGFuIHJvbGU9XCJncmlkY2VsbFwiPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xyS2V5Rm9jdXNJdGVtXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgY2xhc3M9XCJjbHItY29tYm9ib3gtcmVtb3ZlLWJ0blwiXG4gICAgICAgICAgW2Rpc2FibGVkXT1cImNvbnRyb2w/LmRpc2FibGVkPyB0cnVlOiBudWxsXCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbW1vblN0cmluZ3Mua2V5cy5jb21ib2JveERlbGV0ZSArICcgJyArIG9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwudG9TdHJpbmcoZGlzcGxheUZpZWxkLCBpKVwiXG4gICAgICAgICAgKGNsaWNrKT1cInVuc2VsZWN0KGl0ZW0pXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxjZHMtaWNvbiBzaGFwZT1cIndpbmRvdy1jbG9zZVwiIHNpemU9XCIxMlwiPjwvY2RzLWljb24+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbiAgPC9zcGFuPlxuXG4gIDxzcGFuIGNsYXNzPVwiY2xyLWNvbWJvYm94LWlucHV0LXdyYXBwZXJcIj5cbiAgICA8aW5wdXRcbiAgICAgICN0ZXh0Ym94SW5wdXRcbiAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgIHJvbGU9XCJjb21ib2JveFwiXG4gICAgICBbaWRdPVwiaW5wdXRJZCgpXCJcbiAgICAgIGNsYXNzPVwiY2xyLWlucHV0IGNsci1jb21ib2JveC1pbnB1dFwiXG4gICAgICBbKG5nTW9kZWwpXT1cInNlYXJjaFRleHRcIlxuICAgICAgKGJsdXIpPVwib25CbHVyKClcIlxuICAgICAgKGZvY3VzKT1cIm9uRm9jdXMoKVwiXG4gICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cIm9wZW5TdGF0ZVwiXG4gICAgICBbYXR0ci5hcmlhLW93bnNdPVwiYXJpYU93bnNcIlxuICAgICAgYXJpYS1oYXNwb3B1cD1cImxpc3Rib3hcIlxuICAgICAgYXJpYS1hdXRvY29tcGxldGU9XCJsaXN0XCJcbiAgICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgICBbYXR0ci5hcmlhLWludmFsaWRdPVwiY29udHJvbD8uaW52YWxpZD8gdHJ1ZTogbnVsbFwiXG4gICAgICBbZGlzYWJsZWRdPVwiY29udHJvbD8uZGlzYWJsZWQ/IHRydWU6IG51bGxcIlxuICAgICAgW2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImdldEFjdGl2ZURlc2NlbmRhbnQoKVwiXG4gICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgLz5cbiAgPC9zcGFuPlxuXG4gIDwhLS0gTm8gY2xpY2sgaGFuZGxlciwgYXMgaXQgdXNlcyB0aGUgaGFuZGxlciBvbiB0aGUgLmNsci1jb21ib2JveC13cmFwcGVyIC0tPlxuICA8YnV0dG9uXG4gICAgY2xyUG9wb3Zlck9wZW5DbG9zZUJ1dHRvblxuICAgICN0cmlnZ2VyXG4gICAgdHlwZT1cImJ1dHRvblwiXG4gICAgY2xhc3M9XCJjbHItY29tYm9ib3gtdHJpZ2dlclwiXG4gICAgdGFiaW5kZXg9XCItMVwiXG4gICAgW2Rpc2FibGVkXT1cImNvbnRyb2w/LmRpc2FibGVkIHx8IG51bGxcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiY29tbW9uU3RyaW5ncy5rZXlzLmNvbWJvYm94T3BlblwiXG4gID5cbiAgICA8Y2RzLWljb24gc2hhcGU9XCJhbmdsZVwiIGRpcmVjdGlvbj1cImRvd25cIj48L2Nkcy1pY29uPlxuICA8L2J1dHRvbj5cblxuICA8ZGl2IGNsYXNzPVwiY2xyLWZvY3VzLWluZGljYXRvclwiIFtjbGFzcy5jbHItZm9jdXNdPVwiZm9jdXNlZFwiPjwvZGl2PlxuPC9kaXY+XG5cbjwhLS0gQm90aCBjbG9zZSBoYW5kbGVycyBhcmUgaGFuZGxlZCBtYW51YWxseSBkdWUgdG8gaXNzdWVzIGluIEVkZ2UgYnJvd3Nlci5cbiAgICAgQWRkaXRpb25hbGx5ICdvdXRzaWRlQ2xpY2tUb0Nsb3NlJyBoYXMgY29tcGxleCBoYW5kbGluZyB0aGF0J3MgbmVjZXNzYXJ5XG4gICAgIHRvIGJlIG1hbnVhbCBkdWUgdG8gdGhlIGNvbXBvbmVudCBhcmNoaXRlY3R1cmUgLS0+XG48ZGl2IHJvbGU9XCJkaWFsb2dcIiAqY2xyUG9wb3ZlckNvbnRlbnQ9XCJvcGVuU3RhdGUgYXQgc21hcnRQb3NpdGlvbjsgb3V0c2lkZUNsaWNrVG9DbG9zZTogZmFsc2U7IHNjcm9sbFRvQ2xvc2U6IGZhbHNlXCI+XG4gIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuIl19