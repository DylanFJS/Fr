/*
 * Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
 * The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChildren, Input, } from '@angular/core';
import { fromEvent } from 'rxjs';
import { TREE_FEATURES_PROVIDER } from './tree-features.service';
import { TreeFocusManagerService } from './tree-focus-manager.service';
import { ClrTreeNode } from './tree-node';
import * as i0 from "@angular/core";
import * as i1 from "./tree-features.service";
import * as i2 from "./tree-focus-manager.service";
import * as i3 from "@angular/common";
import * as i4 from "./recursive-children";
export class ClrTree {
    constructor(featuresService, focusManagerService, { nativeElement }, renderer, ngZone) {
        this.featuresService = featuresService;
        this.focusManagerService = focusManagerService;
        this.subscriptions = [];
        const subscription = ngZone.runOutsideAngular(() => fromEvent(nativeElement, 'focusin').subscribe((event) => {
            if (event.target === nativeElement) {
                // After discussing with the team, I've made it so that when the tree receives focus, the first visible node will be focused.
                // This will prevent from the page scrolling abruptly to the first selected node if it exist in a deeply nested tree.
                this.focusManagerService.focusFirstVisibleNode();
                // when the first child gets focus,
                // tree should no longer have tabindex of 0.
                renderer.removeAttribute(nativeElement, 'tabindex');
            }
        }));
        this.subscriptions.push(subscription);
    }
    set lazy(value) {
        this.featuresService.eager = !value;
    }
    get isMultiSelectable() {
        return this.featuresService.selectable && this.rootNodes.length > 0;
    }
    ngAfterContentInit() {
        this.setRootNodes();
        this.subscriptions.push(this.rootNodes.changes.subscribe(() => {
            this.setRootNodes();
        }));
    }
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    setRootNodes() {
        // if node has no parent, it's a root node
        // for recursive tree, this.rootNodes registers also nested children
        // so we have to use filter to extract the ones that are truly root nodes
        this.focusManagerService.rootNodeModels = this.rootNodes.map(node => node._model).filter(node => !node.parent);
    }
}
ClrTree.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrTree, deps: [{ token: i1.TreeFeaturesService }, { token: i2.TreeFocusManagerService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
ClrTree.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: ClrTree, selector: "clr-tree", inputs: { lazy: ["clrLazy", "lazy"] }, host: { attributes: { "tabindex": "0" }, properties: { "attr.role": "\"tree\"", "attr.aria-multiselectable": "isMultiSelectable" } }, providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService], queries: [{ propertyName: "rootNodes", predicate: ClrTreeNode }], ngImport: i0, template: `
    <ng-content></ng-content>
    <clr-recursive-children
      *ngIf="featuresService.recursion"
      [children]="featuresService.recursion.root"
    ></clr-recursive-children>
  `, isInline: true, dependencies: [{ kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i4.RecursiveChildren, selector: "clr-recursive-children", inputs: ["parent", "children"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrTree, decorators: [{
            type: Component,
            args: [{
                    selector: 'clr-tree',
                    template: `
    <ng-content></ng-content>
    <clr-recursive-children
      *ngIf="featuresService.recursion"
      [children]="featuresService.recursion.root"
    ></clr-recursive-children>
  `,
                    providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
                    host: {
                        tabindex: '0',
                        '[attr.role]': '"tree"',
                        '[attr.aria-multiselectable]': 'isMultiSelectable',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.TreeFeaturesService }, { type: i2.TreeFocusManagerService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { rootNodes: [{
                type: ContentChildren,
                args: [ClrTreeNode]
            }], lazy: [{
                type: Input,
                args: ['clrLazy']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2RhdGEvdHJlZS12aWV3L3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0dBS0c7QUFFSCxPQUFPLEVBRUwsU0FBUyxFQUNULGVBQWUsRUFFZixLQUFLLEdBS04sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFNBQVMsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFFL0MsT0FBTyxFQUFFLHNCQUFzQixFQUF1QixNQUFNLHlCQUF5QixDQUFDO0FBQ3RGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxhQUFhLENBQUM7Ozs7OztBQWtCMUMsTUFBTSxPQUFPLE9BQU87SUFLbEIsWUFDUyxlQUF1QyxFQUN0QyxtQkFBK0MsRUFDdkQsRUFBRSxhQUFhLEVBQTJCLEVBQzFDLFFBQW1CLEVBQ25CLE1BQWM7UUFKUCxvQkFBZSxHQUFmLGVBQWUsQ0FBd0I7UUFDdEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUE0QjtRQUpqRCxrQkFBYSxHQUFtQixFQUFFLENBQUM7UUFTekMsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxDQUNqRCxTQUFTLENBQUMsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQWlCLEVBQUUsRUFBRTtZQUNsRSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssYUFBYSxFQUFFO2dCQUNsQyw2SEFBNkg7Z0JBQzdILHFIQUFxSDtnQkFDckgsSUFBSSxDQUFDLG1CQUFtQixDQUFDLHFCQUFxQixFQUFFLENBQUM7Z0JBQ2pELG1DQUFtQztnQkFDbkMsNENBQTRDO2dCQUM1QyxRQUFRLENBQUMsZUFBZSxDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsQ0FBQzthQUNyRDtRQUNILENBQUMsQ0FBQyxDQUNILENBQUM7UUFFRixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsSUFDSSxJQUFJLENBQUMsS0FBYztRQUNyQixJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssR0FBRyxDQUFDLEtBQUssQ0FBQztJQUN0QyxDQUFDO0lBRUQsSUFBSSxpQkFBaUI7UUFDbkIsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVELGtCQUFrQjtRQUNoQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQ3JCLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDcEMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQ3RCLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVPLFlBQVk7UUFDbEIsMENBQTBDO1FBQzFDLG9FQUFvRTtRQUNwRSx5RUFBeUU7UUFDekUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqSCxDQUFDOztvR0F2RFUsT0FBTzt3RkFBUCxPQUFPLGdOQVBQLENBQUMsc0JBQXNCLEVBQUUsdUJBQXVCLENBQUMsb0RBUTNDLFdBQVcsNkJBZmxCOzs7Ozs7R0FNVDsyRkFRVSxPQUFPO2tCQWhCbkIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsVUFBVTtvQkFDcEIsUUFBUSxFQUFFOzs7Ozs7R0FNVDtvQkFDRCxTQUFTLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSx1QkFBdUIsQ0FBQztvQkFDNUQsSUFBSSxFQUFFO3dCQUNKLFFBQVEsRUFBRSxHQUFHO3dCQUNiLGFBQWEsRUFBRSxRQUFRO3dCQUN2Qiw2QkFBNkIsRUFBRSxtQkFBbUI7cUJBQ25EO2lCQUNGO3NOQUV1QyxTQUFTO3NCQUE5QyxlQUFlO3VCQUFDLFdBQVc7Z0JBNEJ4QixJQUFJO3NCQURQLEtBQUs7dUJBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyNCBCcm9hZGNvbS4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoZSB0ZXJtIFwiQnJvYWRjb21cIiByZWZlcnMgdG8gQnJvYWRjb20gSW5jLiBhbmQvb3IgaXRzIHN1YnNpZGlhcmllcy5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgVFJFRV9GRUFUVVJFU19QUk9WSURFUiwgVHJlZUZlYXR1cmVzU2VydmljZSB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IFRyZWVGb2N1c01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZvY3VzLW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUcmVlTm9kZSB9IGZyb20gJy4vdHJlZS1ub2RlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRyZWUnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8Y2xyLXJlY3Vyc2l2ZS1jaGlsZHJlblxuICAgICAgKm5nSWY9XCJmZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uXCJcbiAgICAgIFtjaGlsZHJlbl09XCJmZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uLnJvb3RcIlxuICAgID48L2Nsci1yZWN1cnNpdmUtY2hpbGRyZW4+XG4gIGAsXG4gIHByb3ZpZGVyczogW1RSRUVfRkVBVFVSRVNfUFJPVklERVIsIFRyZWVGb2N1c01hbmFnZXJTZXJ2aWNlXSxcbiAgaG9zdDoge1xuICAgIHRhYmluZGV4OiAnMCcsXG4gICAgJ1thdHRyLnJvbGVdJzogJ1widHJlZVwiJyxcbiAgICAnW2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGVdJzogJ2lzTXVsdGlTZWxlY3RhYmxlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZTxUPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyVHJlZU5vZGUpIHByaXZhdGUgcm9vdE5vZGVzOiBRdWVyeUxpc3Q8Q2xyVHJlZU5vZGU8VD4+O1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgZmVhdHVyZXNTZXJ2aWNlOiBUcmVlRmVhdHVyZXNTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgZm9jdXNNYW5hZ2VyU2VydmljZTogVHJlZUZvY3VzTWFuYWdlclNlcnZpY2U8VD4sXG4gICAgeyBuYXRpdmVFbGVtZW50IH06IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgbmdab25lOiBOZ1pvbmVcbiAgKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICBmcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ2ZvY3VzaW4nKS5zdWJzY3JpYmUoKGV2ZW50OiBGb2N1c0V2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IG5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBBZnRlciBkaXNjdXNzaW5nIHdpdGggdGhlIHRlYW0sIEkndmUgbWFkZSBpdCBzbyB0aGF0IHdoZW4gdGhlIHRyZWUgcmVjZWl2ZXMgZm9jdXMsIHRoZSBmaXJzdCB2aXNpYmxlIG5vZGUgd2lsbCBiZSBmb2N1c2VkLlxuICAgICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGZyb20gdGhlIHBhZ2Ugc2Nyb2xsaW5nIGFicnVwdGx5IHRvIHRoZSBmaXJzdCBzZWxlY3RlZCBub2RlIGlmIGl0IGV4aXN0IGluIGEgZGVlcGx5IG5lc3RlZCB0cmVlLlxuICAgICAgICAgIHRoaXMuZm9jdXNNYW5hZ2VyU2VydmljZS5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCBjaGlsZCBnZXRzIGZvY3VzLFxuICAgICAgICAgIC8vIHRyZWUgc2hvdWxkIG5vIGxvbmdlciBoYXZlIHRhYmluZGV4IG9mIDAuXG4gICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKG5hdGl2ZUVsZW1lbnQsICd0YWJpbmRleCcpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICB9XG5cbiAgQElucHV0KCdjbHJMYXp5JylcbiAgc2V0IGxhenkodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciA9ICF2YWx1ZTtcbiAgfVxuXG4gIGdldCBpc011bHRpU2VsZWN0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1NlcnZpY2Uuc2VsZWN0YWJsZSAmJiB0aGlzLnJvb3ROb2Rlcy5sZW5ndGggPiAwO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuc2V0Um9vdE5vZGVzKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLnJvb3ROb2Rlcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0Um9vdE5vZGVzKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRSb290Tm9kZXMoKTogdm9pZCB7XG4gICAgLy8gaWYgbm9kZSBoYXMgbm8gcGFyZW50LCBpdCdzIGEgcm9vdCBub2RlXG4gICAgLy8gZm9yIHJlY3Vyc2l2ZSB0cmVlLCB0aGlzLnJvb3ROb2RlcyByZWdpc3RlcnMgYWxzbyBuZXN0ZWQgY2hpbGRyZW5cbiAgICAvLyBzbyB3ZSBoYXZlIHRvIHVzZSBmaWx0ZXIgdG8gZXh0cmFjdCB0aGUgb25lcyB0aGF0IGFyZSB0cnVseSByb290IG5vZGVzXG4gICAgdGhpcy5mb2N1c01hbmFnZXJTZXJ2aWNlLnJvb3ROb2RlTW9kZWxzID0gdGhpcy5yb290Tm9kZXMubWFwKG5vZGUgPT4gbm9kZS5fbW9kZWwpLmZpbHRlcihub2RlID0+ICFub2RlLnBhcmVudCk7XG4gIH1cbn1cbiJdfQ==